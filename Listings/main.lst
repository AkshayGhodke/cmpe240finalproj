C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE MDU_F120 DEBUG OBJECTEXTEND PRINT(
                    -.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <main.h>
   2          
   3          //-------------------------------------------------------------------------------------------------------
   4          // Global Declarations
   5          //-------------------------------------------------------------------------------------------------------
   6          unsigned char tsByte;
   7          
   8          bit splashEnd = 0;
   9          bit screenReset = 0;
  10          bit ackFromScreen = 0;
  11          bit tsCommandReceived = 0;
  12          bit tsCommandTransmitted = 0;
  13          bit SMB_RW;                                                           // Software flag to indicate Read or Writ
             -e
  14          
  15          unsigned char sharedDataRx[SHARED_DATA_MAX];
  16          unsigned char sharedDataTx[SHARED_DATA_MAX];
  17          unsigned char eepromTx[EEPROM_TX_BUFFER];
  18          unsigned char eepromRx[EEPROM_RX_BUFFER];
  19          unsigned char eepromPageTx[EEPROM_PAGE_SIZE];
  20          
  21          unsigned int pageCount;
  22          unsigned int bytesExtra;
  23          unsigned int eepromPageCounter;
  24          unsigned int startAddr;
  25          unsigned char slaveAddr;                                                // Target SMBus slave address
  26          unsigned char eepromDataByte;
  27          
  28          unsigned int numBytesRD;
  29          unsigned int numBytesWR;
  30          unsigned char slaveWriteDone;
  31          unsigned char slaveReadDone;
  32          unsigned char eepromWriteDone;
  33          unsigned char eepromReaddone;
  34          unsigned char rtcWriteDone;
  35          unsigned char rtcReadDone;
  36          
  37          unsigned char tsRxBuffer[RX_BUFFER_SIZE];
  38          unsigned char tsTxBuffer[TX_BUFFER_SIZE];
  39          unsigned char userCommand[RX_BUFFER_SIZE];
  40          
  41          unsigned int tsRxIn;
  42          unsigned int tsRxOut; 
  43          unsigned int tsTxIn;
  44          unsigned int tsTxOut;
  45          
  46          bit tsRxEmpty;
  47          bit tsTxEmpty;
  48          bit tsLastCharGone; 
  49          
  50          bit screenChanged;
  51          unsigned char screen;
  52          unsigned char lastScreen;
  53          
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 2   

  54          const char code * Font[] = {/*0*/ "m10B", 
  55                        /*1*/ "m12B",
  56                        /*2*/ "m14B",
  57                        /*3*/ "m16B",
  58                        /*4*/ "m20B",
  59                        /*5*/ "m24B",
  60                        /*6*/ "m32B",
  61                        /*7*/ "m48",
  62                        /*8*/ "m64"};
  63          
  64          bit SMB_BUSY = 0;                                                       // Set to claim the bus, clear to free
  65          bit SMB_RW;                                                                     // Software flag to indica
             -te Read or Write
  66          
  67          unsigned int startAddr;
  68          unsigned char slaveAddr;                                                // Target SMBus slave address
  69          
  70          unsigned int numBytesRD;
  71          unsigned int numBytesWR;
  72          
  73          unsigned char slaveWriteDone;
  74          unsigned char slaveReadDone;
  75                                      
  76          //unsigned char roomTemp1;
  77          //unsigned char roomTemp2;
  78          //unsigned char roomTemp3;
  79                        
  80          unsigned char roomTemp;
  81          unsigned char roomTempF;
  82          unsigned int metricUnits = 1; //C is default
  83          char str[SPRINTF_SIZE];
  84                        
  85          char securityCode[SECURITY_CODE];         // Buffer for security code
  86          
  87          unsigned int countDigit;          // Count for the digits entered in code 
  88                                      
  89          unsigned char seconds;
  90          unsigned char minutes;
  91          unsigned char hours;
  92          unsigned char hours24;
  93          unsigned char amPm;
  94          unsigned char day;
  95          unsigned char date;
  96          unsigned char month;
  97          unsigned char year;
  98          unsigned char century;
  99          unsigned char timeMode;
 100          unsigned char currentIndex = 0;
 101          unsigned char minuteIndex = 0;
 102          unsigned char hourIndex = 0;
 103          
 104          unsigned char currentDate;
 105          unsigned char currentMonth;
 106          unsigned char currentYear;
 107          
 108          unsigned char realTimeClockItems;
 109          
 110          unsigned char adjustedSeconds;
 111          unsigned char adjustedMinutes;
 112          unsigned char adjustedHours;
 113          unsigned char adjustedAmPm;
 114          unsigned char adjustedDay;
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 3   

 115          unsigned char adjustedDate;
 116          unsigned char adjustedMonth;
 117          unsigned char adjustedYear;
 118          unsigned char adjustedCentury;
 119          unsigned char adjustedTimeMode;
 120          
 121          bit monthUpdated;
 122          bit dateUpdated;
 123          bit yearUpdated;
 124          bit hoursUpdated;
 125          bit minutesUpdated;
 126          bit secondsUpdated;
 127          bit amPmUpdated;
 128          bit timeUpdated;
 129          bit monthDateYearUpdated;
 130          
 131          const char code * dayOfWeek[] =   {/*0*/  "NON",
 132                             /*1*/  "SUN",
 133                             /*2*/  "MON", 
 134                             /*3*/  "TUE",
 135                             /*4*/  "WED", 
 136                             /*5*/  "THU",
 137                             /*6*/  "FRI", 
 138                             /*7*/  "SAT"}; 
 139          
 140          const char code * monthOfYear[] =   {/*0*/  "NON",
 141                             /*1*/  "JAN",
 142                             /*2*/  "FEB", 
 143                             /*3*/  "MAR",
 144                             /*4*/  "APR", 
 145                             /*5*/  "MAY",
 146                             /*6*/  "JUN", 
 147                             /*7*/  "JUL",
 148                             /*8*/  "AUG",
 149                             /*9*/  "SEP",
 150                             /*10*/ "OCT", 
 151                             /*11*/ "NOV",
 152                             /*12*/ "DEC"};
 153          
 154          const char code * clockSetupMsg[] = {/*0*/  "SET DATE AND TIME      ",
 155                            /*1*/ "WRITING DATA... WAIT!  ",
 156                            /*2*/ "DATA SUCCESSFULLY SAVED",
 157                            /*3*/ "ERROR                  "};
 158          
 159          //-------------------------------------------------------------------------------------------------------
 160          // System Configurations
 161          //-------------------------------------------------------------------------------------------------------
 162          void systemClockInit(void)
 163          {
 164   1          char SFRPAGE_SAVE = SFRPAGE;                            // Save Current SFR page
 165   1        int i = 0;
 166   1          
 167   1        SFRPAGE  = CONFIG_PAGE;
 168   1        
 169   1          OSCICN    = 0x83;
 170   1      
 171   1        SFRPAGE = SFRPAGE_SAVE;                                 // Restore SFRPAGE
 172   1      }
 173          
 174          void portInit(void)
 175          {
 176   1        char SFRPAGE_SAVE = SFRPAGE;                                        // Save Current SFR page
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 4   

 177   1      
 178   1          SFRPAGE = CONFIG_PAGE;                                              // Set SFR page
 179   1      
 180   1        XBR0 = 0x2F;                                // Enable UART0, UART1, SPI0, SMB, CEX0 - CEX4                                      
 181   1          XBR1 = 0x01;                    
 182   1          XBR2 = 0xC4;                                // Enable crossbar and disable weak pull-up                       
 183   1          
 184   1          P0MDOUT = 0x01;                                                     // Set TX0 pin to push-pull
 185   1                                              // TX0 = P0.0; RX0 = P0.1
 186   1        P1MDOUT = 0x01;                               // Set TX1 pin to push-pull, P1.0
 187   1                                              // TX1 = P1.0; RX1 = P1.1
 188   1        P3MDOUT = 0xCA;                               // P3.0, P3.2, P3.4, P3.5: open drain; P3.1, P3.3, P3.6, P3.7: push pull
 189   1        
 190   1        P4MDOUT = 0x0F;                               // P4.0, P4.1, P4.2, P4.3: push pull
 191   1                                              
 192   1        P5MDOUT = 0x04;                               // P5.0 open drain; P5.1 Open drain; P5.2 Push pull
 193   1        
 194   1        P6MDOUT = 0x00;
 195   1                                                                                    
 196   1        P7MDOUT = 0x80;                               // Set P7.7 push-pull (smb error line)
 197   1        
 198   1        P0 = 0xFF;                                  // Initialize port P0 latch
 199   1        P1 = 0xFF;                                  // Initialize port P1 latch
 200   1        P2 = 0xFF;                                  // Initialize port P2 latch
 201   1        P3 = 0xFF;                                  // Initialize port P3 latch
 202   1        P4 = 0xFF;                                  // Initialize port P4 latch
 203   1        P5 = 0xFF;                                  // Initialize port P5 latch
 204   1        P6 = 0xFF;                                  // Initialize port P6 latch
 205   1        P7 = 0xFF;                                  // Initialize port P7 latch
 206   1      
 207   1        RHW = 0;                                  // Pull low SMB error line
 208   1      
 209   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page
 210   1      }
 211          
 212          void enableInterrupts(void)
 213          {
 214   1        IE = 0x92;                                  // Enable all interrupts + UART0 + Timer 0
 215   1        EIE2 |= 0x01;                                                     // Enable Timer 3 interrupt
 216   1        EIE2 |= 0x40;                               // Enable UART1 interrupt
 217   1        EIE1 |= 0x0A;                               // Enable SMBus interrupt
 218   1      }
 219          
 220          void uart0Init(void)
 221          {
 222   1         char SFRPAGE_SAVE;
 223   1      
 224   1         SFRPAGE_SAVE = SFRPAGE;                                              // Preserve SFRPAGE
 225   1      
 226   1         SFRPAGE = TMR2_PAGE;
 227   1         TMR2CN = 0x00;                                                       // Stop timer. Timer 2 in 16-bit auto-
             -reload up timer mode
 228   1         TMR2CF = 0x08;                                                       // SYSCLK is time base; no output; up 
             -count only
 229   1         RCAP2L = 0xF3;                                                               // Low byte
 230   1         RCAP2H = 0xFF;                                                               // High byte
 231   1         TMR2 = RCAP2;                                                                // Load 16 bit reload valu
             -e into timer 2
 232   1         TMR2CN = 0x04;                                                               // Enable timer 2 (Start t
             -imer 2)
 233   1      
 234   1         SFRPAGE = UART0_PAGE;
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 5   

 235   1         SCON0 = 0x50;                                                        // 8-bit variable baud rate; 9th bit i
             -gnored; RX enabled
 236   1         SSTA0 = 0x05;                                                        // Enable baud rate                   
             -                                                
 237   1                                                                              // Use timer 2 as RX and TX baud rate 
             -source
 238   1         IE = 0x90;                                                                   // Enable all interrupts a
             -nd UART0 Interrupt
 239   1      
 240   1         SFRPAGE = SFRPAGE_SAVE;                                              // Restore SFRPAGE
 241   1      }
 242          
 243          void disableWatchdog(void)
 244          {
 245   1        WDTCN = 0xDE;                                               // Disable watchdog timer
 246   1          WDTCN = 0xAD;
 247   1      }
 248          
 249          void uart0Interrupt(void) interrupt INTERRUPT_UART_0 using 2
 250          {
 251   1          char SFRPAGE_SAVE = SFRPAGE;
 252   1        unsigned int i = 0;
 253   1        unsigned long txWaitCounter = 0;
 254   1      
 255   1        SFRPAGE = UART0_PAGE;
 256   1      
 257   1          if(RI0 == 1)                                                        // There is a char in SBUF
 258   1          {
 259   2            RI0 = 0;                                                    // Clear interrupt flag
 260   2      
 261   2            tsByte = SBUF0;                                             // Read a character from UART
 262   2      
 263   2              if(tsRxIn < RX_BUFFER_SIZE)                       // If buffer size is within limit
 264   2              {
 265   3                if(tsByte != '\r')                          // Check end of a command from touch screen
 266   3            {
 267   4              tsRxBuffer[tsRxIn] = tsByte;                  // Store a character in software buffer
 268   4              tsRxIn++;                           // Increment index
 269   4            }
 270   3                else                                // If it is CR character, it marks end of command
 271   3            {                               
 272   4              if(tsRxBuffer[0] == '{')                                        // Splash screen indicator
 273   4              {
 274   5                if(tsRxBuffer[1] == 'c' && tsRxBuffer[2] == 'm' && tsRxBuffer[3] == 'p' && tsRxBuffer[4] == 'e' && ts
             -RxBuffer[5] == '}')
 275   5                {
 276   6                  splashEnd = 1;                                        // Detect end of splash screen
 277   6                  screenReset = 1;                    // Screen was reset, so touch screen sends {babe\r}
 278   6                }
 279   5                else
 280   5                {
 281   6                  splashEnd = 0;                                          // End of splash screen NOT detected
 282   6                  screenReset = 0;                  
 283   6                }
 284   5              }
 285   4              else if(tsRxBuffer[0] == '(')                   // It is a command from touch screen controller
 286   4              {                               // A command starts with '('
 287   5                for(i = 0; i < tsRxIn; i++)
 288   5                {
 289   6                  userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluation
 290   6                }
 291   5      
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 6   

 292   5                ackFromScreen = 0;                      // This is a command, NOT an ACK
 293   5                tsCommandReceived = 1;                    // Set flag when a complete command is received
 294   5              }
 295   4              else                              // Not a command from touch screen controller
 296   4              {
 297   5                ackFromScreen = 1;                      // Set a flag to indicate it is an ACK from screen
 298   5                tsCommandReceived = 0;                    // No need to set flag because it is not a command
 299   5              }
 300   4      
 301   4              for(i = 0; i < tsRxIn; i++)
 302   4              {
 303   5                tsRxBuffer[i] = '\0';                   // Delete all contents
 304   5              }
 305   4              
 306   4              tsRxOut = 0;                          // Reset index Out
 307   4              tsRxIn = 0;                           // Reset index In
 308   4            } 
 309   3              }
 310   2          else                                  // Reset all indexes
 311   2          { 
 312   3            while(tsRxOut < tsRxIn)
 313   3            {
 314   4              tsRxBuffer[tsRxOut] = '\0';
 315   4              tsRxOut++;
 316   4            }
 317   3            tsRxOut = 0;
 318   3            tsRxIn = 0;
 319   3            tsCommandReceived = 0;
 320   3          }
 321   2         }
 322   1      
 323   1         if(TI0 == 1)                                                 // Check if one character is successfully sent out
 324   1         {
 325   2              TI0 = 0;                                                    // Clear interrupt flag
 326   2      
 327   2          if(tsTxEmpty == 0)                            // TX buffer has something to send
 328   2          {
 329   3            SBUF0 = tsTxBuffer[tsTxOut];                    // Send a character in TX buffer
 330   3            tsTxOut++;                              // Move to next character
 331   3      
 332   3            while(TI0 == 0 && txWaitCounter++ < TX_WAIT_LIMIT);         // Wait until completion of transmission TI0 = 
             -1
 333   3            if(txWaitCounter >= TX_WAIT_LIMIT)
 334   3            {
 335   4              TI0 = 1;                            // TI0 is not set by hardware, set it by software
 336   4            }                                 // When TI0 is set to 1, this ISR is executed again
 337   3            
 338   3            txWaitCounter = 0;                          // Reset counter for next execution 
 339   3      
 340   3            if(tsTxOut >= TX_BUFFER_SIZE)
 341   3            {
 342   4              tsTxOut = 0;                          // Reset index to 0
 343   4            }               
 344   3      
 345   3            if(tsTxOut == tsTxIn)                       // If two indexes are equal
 346   3            {
 347   4              tsTxEmpty = 1;                          // No more character in buffer. Empty
 348   4            }
 349   3          }
 350   2          else
 351   2          {
 352   3            tsLastCharGone = 1;                         // Last character has gone. Buffer is empty
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 7   

 353   3          }
 354   2          }
 355   1        
 356   1        SFRPAGE = SFRPAGE_SAVE;                                           // Restore SFR page detector
 357   1      }
 358          
 359          //-------------------------------------------------------------------------------------------------------
 360          // Function Name: sendCommand
 361          // Return Value: None 
 362          // Parmeters: s (a string to send)
 363          // Function Description: This function sends a command from the touch screen
 364          //-------------------------------------------------------------------------------------------------------
 365          void sendCommand(const char * s)
 366          { 
 367   1        char SFRPAGE_SAVE = SFRPAGE;
 368   1        
 369   1        while(*s != '\0')                             // Search for end of touch screen command in buffer
 370   1          {
 371   2              if(tsTxEmpty == 1 || (tsTxOut != tsTxIn))               // Tx is empty or two indexes are not equal
 372   2          {
 373   3            tsTxBuffer[tsTxIn++] = *s;
 374   3            if(tsTxIn >= TX_BUFFER_SIZE)                    // Check for limit
 375   3            {
 376   4              tsTxIn = 0;                           // Reset if limit reached
 377   4            }
 378   3      
 379   3            if(tsTxEmpty == 1)                          // If buffer is empty
 380   3            {
 381   4              tsTxEmpty = 0;                          // Now buffer has at leat 1 character, set flag
 382   4            }
 383   3          }
 384   2            
 385   2          s++;                                  // Point to next char to send out
 386   2          }
 387   1                                              
 388   1        if(tsLastCharGone == 1)                           // All characters in buffer has sent out
 389   1        {
 390   2          tsLastCharGone = 0;                           // Reset flag to indicate no char left in buffer
 391   2          SFRPAGE = UART0_PAGE;                                     
 392   2          TI0 = 1;                                                            // Set this flage to call ISR to send 
             -out one character
 393   2        }                                     
 394   1                                              
 395   1        SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFRPAGE
 396   1      }
 397          
 398          //-------------------------------------------------------------------------------------------------------
 399          // Function Name: displayText
 400          // Return Value: None 
 401          // Parmeters: fg, bg, size, message, x, y
 402          // Function Description: This function displays a text on the touch screen
 403          //-------------------------------------------------------------------------------------------------------
 404          void displayText(const char* fg, const char* bg, const unsigned char size, const char* message, const unsi
             -gned int x, const unsigned int y)
 405          {
 406   1        char str[TS_BUFFER_SIZE];                         // String
 407   1          
 408   1        sprintf(str, "S %s %s\r", fg, bg);                      // Set forground and background color
 409   1        sendCommand(str);                           
 410   1        sprintf(str, "f %s\r", Font[size]);                     // Set text font
 411   1        sendCommand(str);                           
 412   1        sprintf(str, "t \"%s\" %u %u\r", message, x, y);              // Display text
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 8   

 413   1        sendCommand(str);                           
 414   1      }
 415          
 416          //-------------------------------------------------------------------------------------------------------
 417          // Function Name: showBitmap
 418          // Return Value: None 
 419          // Parmeters: index, x, y (bitmap index and coordinates)
 420          // Function Description: This function displays a bitmap image
 421          //-------------------------------------------------------------------------------------------------------
 422          void showBitmap(const unsigned int index, const unsigned int x, const unsigned int y)
 423          {
 424   1        char str[TS_BUFFER_SIZE];
 425   1      
 426   1        sprintf(str, "xi %u %u %u\r", index, x, y);                 // Bitmap index
 427   1        sendCommand(str);
 428   1      }
 429          
 430          //-------------------------------------------------------------------------------------------------------
 431          // Function Name: changeScreen
 432          // Return Value: None 
 433          // Parmeters: screenIndex (macro number)
 434          // Function Description: This function switches to the new screen
 435          //-------------------------------------------------------------------------------------------------------
 436          void changeScreen(const unsigned char screenIndex)
 437          {
 438   1        callMacro(screenIndex);                           // Change screen    
 439   1        screen = screenIndex;
 440   1      }
 441          
 442          //-------------------------------------------------------------------------------------------------------
 443          // Function Name: callMacro
 444          // Return Value: None 
 445          // Parmeters: macroNumber (macro number in the macro file)
 446          // Function Description: This function calls a macro
 447          //-------------------------------------------------------------------------------------------------------
 448          void callMacro(const unsigned int macroNumber)
 449          {
 450   1        char str[TS_BUFFER_SIZE];
 451   1      
 452   1        sprintf(str, "m %u\r", macroNumber);                    // Execute macro number
 453   1        sendCommand(str);
 454   1      }
 455          
 456          // C - F
 457          unsigned char celciusToFarenheit(unsigned char roomTemp){
 458   1        return (unsigned char)((int)roomTemp * 1.8 + 33);
 459   1      }
 460          
 461          // Display '*' for each digit entered
 462          void confScreen(countDigit){
 463   1                  switch(countDigit)
 464   1                  {
 465   2                    case '1':
 466   2                      sprintf(str, '*');
 467   2                      displayText("000000", "FFFFFF", 6, str, 50, 50);
 468   2                      break;
 469   2                    case '2':
 470   2                      sprintf(str, "* *");
 471   2                      displayText("000000", "FFFFFF", 6, str, 50, 50);
 472   2                      break;
 473   2                    case '3':
 474   2                      sprintf(str, "* * *");
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 9   

 475   2                      displayText("000000", "FFFFFF", 6, str, 50, 50);
 476   2                      break;
 477   2                    case '4':   
 478   2                      sprintf(str, "* * * *");
 479   2                      displayText("000000", "FFFFFF", 6, str, 50, 50);
 480   2                      break;
 481   2                    default:
 482   2                      break;
 483   2                }
 484   1      }
 485          
 486          void printTempF(void){
 487   1                  roomTemp = readOneByteFromSlave(ROOM_TEMP);
 488   1                  roomTempF = celciusToFarenheit(roomTemp);
 489   1                  sprintf(str, "%-5bu F", roomTempF); 
 490   1                  displayText("000000", "FFFFFF", 5, str,  270, 215);
 491   1      }
 492          
 493          void printTempC(void){
 494   1                  roomTemp = readOneByteFromSlave(ROOM_TEMP);
 495   1                  sprintf(str, "%-5bu C", roomTemp);
 496   1                  displayText("000000", "FFFFFF", 5, str,  270, 215);
 497   1      
 498   1      }
 499          
 500          //-------------------------------------------------------------------------------------------------------
 501          // Function Name: scanUserInput
 502          // Return Value: None 
 503          // Parmeters: None
 504          // Function Description: This function processes commands from the touch screen
 505          //-------------------------------------------------------------------------------------------------------
 506          void scanUserInput(void)
 507          { 
 508   1        int i = 0;
 509   1      
 510   1        if(screen == MAIN_PAGE)                           // Main screen
 511   1        {
 512   2          if(userCommand[0] == '(')                       // Check for an actual command followed by this '(' character
 513   2          {
 514   3            switch (userCommand[1])                         // Scan a command type
 515   3            {
 516   4              case '1':                           // Main page
 517   4                changeScreen(MAIN_PAGE);                  // Stay in main page if main button is pressed again
 518   4                break;
 519   4              case '2':                           // Settings page
 520   4                changeScreen(SETTINGS_PAGE);
 521   4                break;
 522   4              case '3':                             // Service page
 523   4                changeScreen(SERVICE_PAGE);
 524   4                break;
 525   4              case '4':                             // Service page
 526   4                changeScreen(CONF_PAGE);
 527   4                break;
 528   4              case 'A':
 529   4                //callMacro(3);
 530   4              //while(1){
 531   4                  printTempC(); 
 532   4                  metricUnits = 1;
 533   4                break;
 534   4              case 'B':
 535   4                //while(1){
 536   4                    printTempF();
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 10  

 537   4                    metricUnits = 0;
 538   4                //}
 539   4                break;
 540   4              case 'C':
 541   4                break;  
 542   4              default:            // Other options
 543   4                //while(1){
 544   4                  //roomTemp = readOneByteFromSlave(ROOM_TEMP);
 545   4                  //roomTempF = celciusToFarenheit(roomTemp);
 546   4                  //sprintf(str, "%-5bu F", roomTempF); 
 547   4                  //displayText("000000", "FFFFFF", 5, str,  270, 215);
 548   4                //}
 549   4                break;
 550   4              }
 551   3            
 552   3          }
 553   2          else                                  // Not a command, empty buffer with nullchar
 554   2          {
 555   3            i = 0;
 556   3            while(userCommand[i] != '\0')
 557   3            {
 558   4              userCommand[i] = '\0';
 559   4              i++;
 560   4            }
 561   3          } 
 562   2        }
 563   1        else if(screen == SETTINGS_PAGE)                      // Settings page
 564   1        {
 565   2          if(userCommand[0] == '(')
 566   2          {
 567   3            switch (userCommand[1])
 568   3            {
 569   4              case '1':
 570   4                changeScreen(MAIN_PAGE);
 571   4                break;
 572   4              case '2':
 573   4                changeScreen(SETTINGS_PAGE);
 574   4                break;
 575   4              case '3':
 576   4                changeScreen(SERVICE_PAGE);
 577   4                break;
 578   4              case 'C':
 579   4                //decreaseBrightness
 580   4                callMacro(24);
 581   4                break;
 582   4              case 'D':
 583   4                //increaseBrightness
 584   4                callMacro(25);
 585   4                break;
 586   4              case 'E':
 587   4                //decreaseContrast();
 588   4                  // Call a function here or do something here
 589   4                break;
 590   4              case 'F':
 591   4                //increaseContrast();
 592   4                // Call a function here or do something here
 593   4                break;  
 594   4              case 'G':
 595   4                //decreseBeamWidth();
 596   4                // Call a function here or do something here
 597   4                break;  
 598   4              case 'H':
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 11  

 599   4                //increaseBeamWidth();
 600   4                // Call a function here or do something here
 601   4                break;  
 602   4              default:
 603   4                break;
 604   4            }
 605   3          }
 606   2          else                                  // Not a command, empty buffer with null
 607   2          {
 608   3            i = 0;
 609   3            while(userCommand[i] != '\0')
 610   3            {
 611   4              userCommand[i] = '\0';
 612   4              i++;
 613   4            }
 614   3          }       
 615   2        }
 616   1        else if(screen == SERVICE_PAGE)
 617   1        {
 618   2          if(userCommand[0] == '(')
 619   2          {
 620   3            switch (userCommand[1])
 621   3            {
 622   4              case '1':
 623   4                changeScreen(MAIN_PAGE);
 624   4                break;
 625   4              case '2':
 626   4                changeScreen(SETTINGS_PAGE);
 627   4                break;
 628   4              case '3':
 629   4                changeScreen(SERVICE_PAGE);
 630   4                break;
 631   4              case 'A':
 632   4                if( countDigit != 4)
 633   4                {
 634   5                countDigit += sprintf(securityCode + countDigit,'0');
 635   5                }
 636   4                break;
 637   4                // Call a function here or do something here
 638   4              case 'B':
 639   4                if( countDigit != 4)
 640   4                {
 641   5                countDigit += sprintf(securityCode + countDigit,'1');
 642   5                }
 643   4                else
 644   4                {
 645   5                  //displayMessage();     // display error message
 646   5                }
 647   4                break;
 648   4              case 'C':
 649   4                if( countDigit != 4)
 650   4                {
 651   5                countDigit += sprintf(securityCode + countDigit,'2');
 652   5                }
 653   4                break;
 654   4              case 'D':
 655   4                if( countDigit != 4)
 656   4                {
 657   5                countDigit += sprintf(securityCode + countDigit,'3');
 658   5                }
 659   4                break;
 660   4              case 'E':
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 12  

 661   4                if( countDigit != 4)
 662   4                {
 663   5                countDigit += sprintf(securityCode + countDigit,'4');
 664   5                }
 665   4                break;
 666   4              case 'F':
 667   4                if( countDigit != 4)
 668   4                {
 669   5                countDigit += sprintf(securityCode + countDigit,'5');
 670   5                }
 671   4                break;
 672   4              case 'G':
 673   4                if( countDigit != 4)
 674   4                {
 675   5                countDigit += sprintf(securityCode + countDigit,'6');
 676   5                }
 677   4                break;
 678   4              case 'H':
 679   4                if( countDigit != 4)
 680   4                {
 681   5                countDigit += sprintf(securityCode + countDigit,'7');
 682   5                }
 683   4                break;
 684   4              case 'I':
 685   4                if( countDigit != 4)
 686   4                {
 687   5                countDigit += sprintf(securityCode + countDigit,'8');
 688   5                }
 689   4                break;
 690   4              case 'J':
 691   4                if( countDigit != 4)
 692   4                {
 693   5                countDigit += sprintf(securityCode + countDigit,'9');
 694   5                }
 695   4                break;
 696   4              
 697   4              case 'X':
 698   4                //countDigit = 0;
 699   4                
 700   4                sprintf(securityCode,'0');
 701   4                break;
 702   4                // Call a function here or do something here
 703   4              case 'Y':
 704   4                if( securityCode == "2345")
*** WARNING C185 IN LINE 704 OF main.c: '==': different memory space
 705   4                {
 706   5                    changeScreen(CONF_PAGE);
 707   5                }
 708   4                else
 709   4                {
 710   5                  countDigit = 0;
 711   5                  sprintf(securityCode,'0');
 712   5                  //displayMessage();             // To display Message >> "Wrong Code" in a text window
 713   5                }
 714   4                break;
 715   4                // Call a function here or do something here
 716   4              default:
 717   4                break;
 718   4            }
 719   3          }
 720   2          else                                  // Not a command, empty buffer with null
 721   2          {                               
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 13  

 722   3            i = 0;
 723   3            while(userCommand[i] != '\0')
 724   3            {
 725   4              userCommand[i] = '\0';
 726   4              i++;
 727   4            }
 728   3          }       
 729   2        } 
 730   1        else if(screen == CONF_PAGE)
 731   1        {
 732   2          if(userCommand[0] == '(')
 733   2          {
 734   3            switch (userCommand[1])
 735   3            {
 736   4              case '3':
 737   4                changeScreen(SERVICE_PAGE);
 738   4              case 'I':
 739   4                //decreaseVoltage();
 740   4                break;
 741   4              case 'J':
 742   4                //increaseVoltage();
 743   4                break;
 744   4              case 'K':
 745   4                //decreaseCurrent();
 746   4                break;
 747   4              case 'L':
 748   4                ////increaseCurrent();
 749   4                // Call a function here or do something here
 750   4              case 'M':
 751   4                //decreasePower();
 752   4                // Call a function here or do something here
 753   4              case 'N':
 754   4                //increasePower();
 755   4                // Call a function here or do something here
 756   4              default:
 757   4                break;
 758   4            }
 759   3          }
 760   2          else                                  // Not a command, empty buffer with null
 761   2          {                               
 762   3            i = 0;
 763   3            while(userCommand[i] != '\0')
 764   3            {
 765   4              userCommand[i] = '\0';
 766   4              i++;
 767   4            }
 768   3          }       
 769   2        } 
 770   1        else if(screen == TEMP_PAGE)
 771   1        {
 772   2          if(userCommand[0] == '(')
 773   2          {
 774   3            switch (userCommand[1])
 775   3            {
 776   4              case '1':
 777   4                changeScreen(MAIN_PAGE);
 778   4                break;
 779   4              case '2':
 780   4                changeScreen(SETTINGS_PAGE);
 781   4                break;
 782   4              case '3':
 783   4                changeScreen(SERVICE_PAGE);
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 14  

 784   4                break;
 785   4              case 'A':
 786   4                //callMacro(3);
 787   4              //while(1){
 788   4                    roomTemp = readOneByteFromSlave(ROOM_TEMP);
 789   4                    roomTempF = celciusToFarenheit(roomTemp);
 790   4                    sprintf(str, "%-5bu F", roomTempF); 
 791   4                    displayText("000000", "FFFFFF", 5, str, 255, 215);
 792   4              //}
 793   4                // Call a function here or do something here      
 794   4                break;
 795   4              case 'B':
 796   4                //while(1){
 797   4                //callMacro(3);
 798   4                  roomTemp = readOneByteFromSlave(ROOM_TEMP);
 799   4                  sprintf(str, "%-5bu C", roomTemp);
 800   4                  displayText("000000", "FFFFFF", 5, str, 255, 215);
 801   4                //}
 802   4                 // Call a function here  or do something here
 803   4                break;
 804   4              case 'C':
 805   4                // Call a function here or do something here
 806   4                break;  
 807   4              default:            // Other options
 808   4                  roomTemp = readOneByteFromSlave(ROOM_TEMP);
 809   4                  roomTempF = celciusToFarenheit(roomTemp);
 810   4                  sprintf(str, "%-5bu F", roomTempF); 
 811   4                  displayText("000000", "FFFFFF", 5, str, 255, 215);
 812   4                break;
 813   4            }
 814   3          }
 815   2          else                                  // Not a command, empty buffer with null
 816   2          {                               
 817   3            i = 0;
 818   3            while(userCommand[i] != '\0')
 819   3            {
 820   4              userCommand[i] = '\0';
 821   4              i++;
 822   4            }
 823   3          }       
 824   2        }
 825   1        else
 826   1        {
 827   2      
 828   2        }
 829   1      
 830   1        i = 0;
 831   1        while(userCommand[i] != '\0')
 832   1        {
 833   2          userCommand[i] = '\0';                          // Delete all contents in array
 834   2          i++;
 835   2        }
 836   1      }
 837          
 838          //-------------------------------------------------------------------------------------------------------
 839          // Function Name: smbInit
 840          // Return Value: None 
 841          // Parmeters: None
 842          // Function Description: This function initializes the SMB bus 
 843          //-------------------------------------------------------------------------------------------------------
 844          void smbInit(void)
 845          {
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 15  

 846   1          int i;
 847   1        unsigned long pollingCounter = 0;
 848   1        char SFRPAGE_SAVE = SFRPAGE;
 849   1      
 850   1          SFRPAGE = SMB0_PAGE;
 851   1        while(SDA == 0 && pollingCounter++ < SMB_POLLING_LIMIT)             // If slave is holding SDA low because of e
             -rror or reset
 852   1          {
 853   2              SCL = 0;                                                          // Drive the clock low
 854   2              for(i = 0; i < 255; i++);                                         // Hold the clock low
 855   2              SCL = 1;                                                          // Release the clock
 856   2              while(SCL == 0 && pollingCounter++ < SMB_POLLING_LIMIT);          // Wait for open-drain
 857   2              for(i = 0; i < 10; i++);                                          // Hold the clock high
 858   2          }
 859   1            
 860   1        SMB0CN = 0x07;                                                      // Assert Acknowledge low (AA bit = 1b);
 861   1                                                                              // Enable SMBus Free timeout detect;
 862   1        SMB0CR = 267 - (SYSTEM_CLOCK / (8 * SMB_FREQUENCY));              // Derived approximation from the Tlow and Thi
             -gh equations
 863   1                                        
 864   1          SMB0CN |= 0x40;                                                     // Enable SMBus;
 865   1      
 866   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page detector
 867   1        
 868   1        SMB_BUSY = 0;
 869   1                                                                                          // Release SMB
 870   1          slaveWriteDone = FALSE;
 871   1        slaveReadDone = FALSE;
 872   1        eepromWriteDone = FALSE;
 873   1        eepromReadDone = FALSE;
 874   1        rtcWriteDone = FALSE;
 875   1        rtcReadDone = FALSE;
 876   1      }
 877          
 878          //-------------------------------------------------------------------------------------------------------
 879          // Function Name: timer3Init
 880          // Return Value: None 
 881          // Parmeters: None
 882          // Function Description: This function nitializes timer 3 which is used to time out the SMB if errors occu
             -r
 883          //-------------------------------------------------------------------------------------------------------
 884          void timer3Init (void)
 885          {
 886   1          char SFRPAGE_SAVE = SFRPAGE;        
 887   1      
 888   1          SFRPAGE = TMR3_PAGE;
 889   1      
 890   1          TMR3CN = 0x00;                                                      // Timer 3 in timer mode
 891   1                                                // Timer 3 auto reload
 892   1          TMR3CF = 0x00;                                                      // Timer 3 prescaler = 12
 893   1      
 894   1          RCAP3 = -(SYSTEM_CLOCK / 12 / 40);                                    // Timer 3 overflows after 25 ms
 895   1          TMR3 = RCAP3;                                                     
 896   1      
 897   1          TR3 = 1;                                                            // Start Timer 3
 898   1      
 899   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page
 900   1      }
 901          
 902          //-------------------------------------------------------------------------------------------------------
 903          // Function Name: timer3ISR
 904          // Return Value: None 
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 16  

 905          // Parmeters: None
 906          // Function Description: This function is timer 3 ISR which is used to reset the SMB bus if the clock line
             - is held for too long
 907          //-------------------------------------------------------------------------------------------------------
 908          void timer3ISR(void) interrupt INTERRUPT_Timer_3
 909          {
 910   1          char SFRPAGE_SAVE = SFRPAGE;                                        // Save Current SFR page
 911   1      
 912   1          SFRPAGE = SMB0_PAGE;
 913   1          SMB0CN &= ~0x40;                                                    // Disable SMBus
 914   1          SMB0CN |= 0x40;                                                     // Re-enable SMBus
 915   1      
 916   1          SFRPAGE = SFRPAGE_SAVE;                                             // Switch back to the Timer3 SFRPAGE
 917   1          TF3 = 0;                                                            // Clear Timer3 interrupt-pending flag
 918   1          SMB_BUSY = 0;                                                       // Free bus
 919   1         
 920   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page detector
 921   1      }
 922          
 923          //-------------------------------------------------------------------------------------------------------
 924          // Function Name: writeOneByteToSlave
 925          // Return Value: None 
 926          // Parmeters: target, startAddr, content
 927          // Function Description: This function writes one to the slave microprocessor
 928          //-------------------------------------------------------------------------------------------------------
 929          void writeOneByteToSlave(unsigned char startAddr, unsigned char content)
 930          {       
 931   1        sharedDataTx[startAddr] = content;
 932   1        smbWrite(MCU_SLAVE_ADDR, startAddr, 1);
 933   1      }
 934          
 935          //-------------------------------------------------------------------------------------------------------
 936          // Function Name: readOneByteFromSlave
 937          // Return Value: long 
 938          // Parmeters: startAddr, bytes
 939          // Function Description: This function reads one from the slave microprocessor
 940          //-------------------------------------------------------------------------------------------------------
 941          unsigned char readOneByteFromSlave(unsigned char startAddr)
 942          {
 943   1        smbRead(MCU_SLAVE_ADDR, startAddr, 1);
 944   1        return sharedDataRx[startAddr];                                               
 945   1      }
 946          
 947          //-------------------------------------------------------------------------------------------------------
 948          // Function Name: writeBytesToRealTimeClock
 949          // Return Value: None 
 950          // Parmeters: target, startAddr, bytes
 951          // Function Description: This function writes data byte to the real time clock DS3232
 952          //-------------------------------------------------------------------------------------------------------
 953          void writeBytesToRealTimeClock(unsigned char startAddr, unsigned char numBytes)
 954          {
 955   1        smbWrite(REAL_TIME_CLOCK_ADDR, startAddr, numBytes);
 956   1      }
 957          
 958          //-------------------------------------------------------------------------------------------------------
 959          // Function Name: readBytesFromRealTimeClock
 960          // Return Value: None 
 961          // Parmeters: target, startAddr, bytes
 962          // Function Description: This function reads data byte from the real time clock DS3232
 963          //-------------------------------------------------------------------------------------------------------
 964          void readBytesFromRealTimeClock(unsigned char startAddr, unsigned char numBytes)
 965          {
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 17  

 966   1        smbRead(REAL_TIME_CLOCK_ADDR, startAddr, numBytes);
 967   1      }
 968          
 969          //-------------------------------------------------------------------------------------------------------
 970          // Function Name: smbRead
 971          // Return Value: unsigned char * 
 972          // Parmeters: target, startAddr, bytes
 973          // Function Description: This function reads from SM bus
 974          //-------------------------------------------------------------------------------------------------------
 975          void smbRead(unsigned char deviceId, unsigned int location, unsigned int bytes)
 976          {
 977   1        char SFRPAGE_SAVE = SFRPAGE;
 978   1      
 979   1        SFRPAGE = SMB0_PAGE;
 980   1        
 981   1        while(BUSY || SMB_BUSY);                                                // Wait for free SMB
 982   1      
 983   1        SFRPAGE = SFRPAGE_SAVE;
 984   1          
 985   1          switch(deviceId)
 986   1          {
 987   2              case MCU_SLAVE_ADDR:
 988   2              case REAL_TIME_CLOCK_ADDR:
 989   2              case EEPROM_ADDR:
 990   2                  smbWrite(deviceId, location, 0);                      // Write address before reading
 991   2                  break;
 992   2              default:
 993   2                  break;  
 994   2          }
 995   1      
 996   1          SFRPAGE = SMB0_PAGE;
 997   1          
 998   1          while(BUSY || SMB_BUSY);
 999   1          slaveAddr = deviceId;                                                     // Address of MCU slave
1000   1          startAddr = location;                                 // Starting address to read from slave
1001   1          numBytesRD = bytes;                                   // Number of bytes to read
1002   1          
1003   1          SMB_BUSY = 1;                                                           // Claim SMBus (set to busy)
1004   1          SMB_RW = 1;                                                             // Mark this transfer as a READ
1005   1          STA = 1;
1006   1      
1007   1        while(BUSY || SMB_BUSY);                                                    // Wait for SMB
1008   1          
1009   1        SFRPAGE = SFRPAGE_SAVE;
1010   1            
1011   1          switch(deviceId)
1012   1          {
1013   2              case MCU_SLAVE_ADDR:
1014   2                  while(slaveReadDone == 0);                                            // Wait until slave write 
             -completed
1015   2                  break;
1016   2              case REAL_TIME_CLOCK_ADDR:
1017   2            while(rtcReadDone == 0);                                            // Wait until real time clock write c
             -ompleted or timeout occurs
1018   2            break;
1019   2              case EEPROM_ADDR:
1020   2                  while(eepromReadDone == 0);                                           // Wait until EEPROM writ
             -e completed
1021   2                  break;
1022   2              default:
1023   2                  break;  
1024   2          }  
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 18  

1025   1      }
1026          
1027          //-------------------------------------------------------------------------------------------------------
1028          // Function Name: smbWrite
1029          // Return Value: unsigned char * 
1030          // Parmeters: target, startAddr, bytes
1031          // Function Description: This function reads to SM bus
1032          //-------------------------------------------------------------------------------------------------------
1033          void smbWrite(unsigned char deviceId, unsigned int location, unsigned int bytes)
1034          {
1035   1        unsigned char i = 0;
1036   1        unsigned int pageWrittenDelay = 0;
1037   1        char SFRPAGE_SAVE = SFRPAGE;
1038   1          
1039   1        SFRPAGE = SMB0_PAGE;
1040   1        
1041   1        while(BUSY || SMB_BUSY);                                                // Wait for SMB to be free
1042   1          slaveAddr = deviceId;                                                   // Address of MCU slave board
1043   1          startAddr = location;                               // Starting address to write to slave
1044   1      
1045   1          switch(deviceId)
1046   1          {
1047   2              case MCU_SLAVE_ADDR:                              // Pass through
1048   2              case DEVICE_DUMP_ADDR:                              // Pass through
1049   2                  numBytesWR = bytes;                             // Number of bytes to read
1050   2                  SMB_BUSY = 1;                                                     // Claim SMBus (set to busy)
1051   2                  SMB_RW = 0;                                                       // Mark this transfer as a WRIT
             -E
1052   2                  STA = 1;                                                          // Start transfer
1053   2                  while(slaveWriteDone == 0);                                             // Wait until SRAM wri
             -te completed or timeout occurs
1054   2                  break;
1055   2              case REAL_TIME_CLOCK_ADDR:
1056   2                  numBytesWR = bytes;                             // Number of bytes to read
1057   2                  SMB_BUSY = 1;                                                     // Claim SMBus (set to busy)
1058   2                  SMB_RW = 0;                                                       // Mark this transfer as a WRIT
             -E
1059   2                  STA = 1;                                                          // Start transfer
1060   2                  while(rtcWriteDone == 0);                                             // Wait until SRAM write
             - completed or timeout occurs
1061   2                  break;
1062   2              default:
1063   2                  break;    
1064   2        }
1065   1      
1066   1        SFRPAGE = SFRPAGE_SAVE;                             // Restore SFR page
1067   1      }
1068          
1069          //-------------------------------------------------------------------------------------------------------
1070          // Function Name: smbISR
1071          // Return Value: None 
1072          // Parmeters: None
1073          // Function Description: 
1074          // SMBus Interrupt Service Routine (ISR)
1075          // Anytime the SDA is pulled low by the master, this ISR will be called. For example, if STA = 1,
1076          // this ISR is called and SMB0STA = SMB_START = SMB_REPEAT_START. These cases are executed within the swit
             -ch statement.
1077          //-------------------------------------------------------------------------------------------------------
1078          void smbISR (void) interrupt INTERRUPT_SMB using 2
1079          {
1080   1          bit FAIL = 0;                                                       // Used by the ISR to flag failed trans
             -fers
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 19  

1081   1          static unsigned int TxCounter;                          // Initialize counter
1082   1          static unsigned int RxCounter;                          // Initialize counter
1083   1        static unsigned int slaveCount = 0;
1084   1        static unsigned int realTimeClockCount = 0;
1085   1        static unsigned int eepromCount = 0;
1086   1        static unsigned char eepromAddrDone;
1087   1        
1088   1        switch (SMB0STA >> 3)                             // Check SMB bus status
1089   1          {
1090   2      //-------------------------------------------------------------------------------------------------------
1091   2      // Master Transmitter/Receiver: START condition transmitted. Load SMB0DAT with slave device address
1092   2      //-------------------------------------------------------------------------------------------------------
1093   2              case SMB_START:                               // Master initiates a transfer
1094   2      
1095   2      //-------------------------------------------------------------------------------------------------------
1096   2      // Master Transmitter/Receiver: repeated START condition transmitted. Load SMB0DAT with slave device addre
             -ss
1097   2      //-------------------------------------------------------------------------------------------------------
1098   2              case SMB_REPEAT_START:
1099   2            SMB0DAT = slaveAddr;                                            // Load address of the slave.
1100   2                SMB0DAT &= 0xFE;                                              // Clear the LSB of the address for the
             - R/W bit
1101   2                SMB0DAT |= SMB_RW;                                            // Load R/W bit (Read = 1; Write = 0)
1102   2            STA = 0;                                                      // Manually clear STA bit
1103   2      
1104   2                RxCounter = 0;                                                // Reset the counter
1105   2                TxCounter = 0;                                                // Reset the counter
1106   2            eepromAddrDone = CLEAR;                         // For 2 byte EEPROM address  
1107   2                
1108   2            break;
1109   2      
1110   2      //-------------------------------------------------------------------------------------------------------
1111   2      // Master Transmitter: Slave address + WRITE transmitted.  ACK received. For a READ: N/A
1112   2      // For a WRITE: Send the first data byte to the slave
1113   2      //-------------------------------------------------------------------------------------------------------
1114   2              case SMB_ADDR_W_TX_ACK_RX:
1115   2            if(slaveAddr == MCU_SLAVE_ADDR)
1116   2            {
1117   3              if(startAddr == DEVICE_DUMP_ADDR)                 // Dump device address to check slave presence only
1118   3              {
1119   4                STO = 1;                            // Stop this transfer
1120   4                SMB_BUSY = 0;                         // Releas SMB
1121   4              }
1122   3              else
1123   3              {
1124   4                SMB0DAT = startAddr;                      // Send 1 byte address to slave
1125   4                slaveWriteDone = 0;                       // Mark start of slave write
1126   4              }
1127   3            }
1128   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1129   2            {
1130   3              SMB0DAT = startAddr;                        // Point to byte address to write on real time clock
1131   3              rtcWriteDone = 0;                         // Mark start of rtc write
1132   3            }
1133   2                  else{}
1134   2                break;
1135   2      
1136   2      //-------------------------------------------------------------------------------------------------------
1137   2      // Master Transmitter: Slave address + WRITE transmitted.  NACK received. Restart the transfer
1138   2      //-------------------------------------------------------------------------------------------------------
1139   2              case SMB_ADDR_W_TX_NACK_RX:
1140   2            if(slaveAddr == MCU_SLAVE_ADDR)
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 20  

1141   2            {
1142   3              if(slaveCount < MAX_NACK_RETRY)
1143   3              {
1144   4                slaveCount++;                         // Increment number of attempts when NACK is received
1145   4                STA = 1;                            // Restart a new transfer
1146   4              }
1147   3              else
1148   3              {
1149   4                slaveCount = 0;                         // Reset this counter to keep retry seeking slave response
1150   4                slaveWriteDone = 1;
1151   4                STO = 1;
1152   4                SMB_BUSY = 0;
1153   4                FAIL = 1;
1154   4              } 
1155   3            }
1156   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1157   2            {
1158   3              if(realTimeClockCount < MAX_NACK_RETRY)
1159   3              {
1160   4                realTimeClockCount++;                     // Increment number of attempts when NACK is received
1161   4                STA = 1;                            // Restart a new transfer
1162   4              }
1163   3              else
1164   3              {
1165   4                realTimeClockCount = 0;
1166   4                rtcWriteDone = 1;
1167   4                STO = 1;
1168   4                SMB_BUSY = 0;
1169   4                FAIL = 1;
1170   4              } 
1171   3            }
1172   2            else if(slaveAddr == EEPROM_ADDR)
1173   2            {
1174   3              if(eepromCount < MAX_NACK_RETRY)
1175   3              {
1176   4                eepromCount++;                          // Increment number of attempts when NACK is received
1177   4                STA = 1;                            // Restart a new transfer
1178   4              }
1179   3              else
1180   3              {
1181   4                eepromCount = 0;
1182   4                eepromWriteDone = 1;
1183   4                STO = 1;
1184   4                SMB_BUSY = 0;
1185   4                FAIL = 1;
1186   4              } 
1187   3            }
1188   2            else
1189   2            {}
1190   2      
1191   2                break;
1192   2      
1193   2      //-------------------------------------------------------------------------------------------------------
1194   2      //Master Transmitter: Data byte transmitted.  ACK received. For a READ: N/A
1195   2      //For a WRITE: Send all data.  After the last data byte, send the stop bit
1196   2      //-------------------------------------------------------------------------------------------------------
1197   2              case SMB_DATA_TX_ACK_RX:
1198   2                if(slaveAddr == MCU_SLAVE_ADDR)
1199   2            {
1200   3              if(TxCounter < numBytesWR)
1201   3                  {
1202   4                SMB0DAT = sharedDataTx[startAddr + TxCounter];          // Send data byte
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 21  

1203   4                      TxCounter++;
1204   4                  }
1205   3                  else
1206   3                  {
1207   4                      STO = 1;                                                // Set STO to terminate transfer                
             -        
1208   4                      SMB_BUSY = 0;                                           // And free SMBus interface
1209   4                slaveWriteDone = 1;                       // Mark end of slave write
1210   4                  }
1211   3            }
1212   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1213   2            {
1214   3              if(TxCounter < numBytesWR)
1215   3                  {
1216   4                SMB0DAT = sharedDataTx[startAddr + TxCounter];          // Send data byte
1217   4                      TxCounter++;
1218   4                  }
1219   3                  else
1220   3                  {
1221   4                      STO = 1;                                                // Set STO to terminate transfer                
             -        
1222   4                      SMB_BUSY = 0;                                           // And free SMBus interface
1223   4                rtcWriteDone = 1;                       // Mark end of slave write
1224   4                  }
1225   3            }
1226   2                break;
1227   2      
1228   2      //-------------------------------------------------------------------------------------------------------
1229   2      // Master Transmitter: Data byte transmitted.  NACK received. Restart the transfer
1230   2      //-------------------------------------------------------------------------------------------------------
1231   2              case SMB_DATA_TX_NACK_RX:
1232   2            if(slaveAddr == MCU_SLAVE_ADDR)
1233   2            {
1234   3              if(slaveCount < MAX_NACK_RETRY)
1235   3              {
1236   4                slaveCount++;                         // Increment number of attempts when NACK is received
1237   4                STA = 1;                            // Restart a new transfer
1238   4              }
1239   3              else
1240   3              {
1241   4                slaveCount = 0;
1242   4                STO = 1;
1243   4                SMB_BUSY = 0;
1244   4                FAIL = 1;
1245   4              } 
1246   3            }
1247   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1248   2            {
1249   3              if(realTimeClockCount < MAX_NACK_RETRY)
1250   3              {
1251   4                realTimeClockCount++;                     // Increment number of attempts when NACK is received
1252   4                STA = 1;                            // Restart a new transfer
1253   4              }
1254   3              else
1255   3              {
1256   4                realTimeClockCount = 0;
1257   4                STO = 1;
1258   4                SMB_BUSY = 0;
1259   4                FAIL = 1;
1260   4              } 
1261   3            }
1262   2            else if(slaveAddr == EEPROM_ADDR)
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 22  

1263   2            {
1264   3              if(eepromCount < MAX_NACK_RETRY)
1265   3              {
1266   4                eepromCount++;                          // Increment number of attempts when NACK is received
1267   4                STA = 1;                            // Restart a new transfer
1268   4              }
1269   3              else
1270   3              {
1271   4                eepromCount = 0;
1272   4                STO = 1;
1273   4                SMB_BUSY = 0;
1274   4                FAIL = 1;
1275   4              } 
1276   3            }
1277   2            else
1278   2            {}
1279   2                break;
1280   2      
1281   2      //-------------------------------------------------------------------------------------------------------
1282   2      // Master Receiver: Slave address + READ transmitted.  ACK received. 
1283   2      // For a READ: check if this is a one-byte transfer. if so, set the NACK after the data byte
1284   2      // is received to end the transfer. if not, set the ACK and receive the other data bytes
1285   2      //-------------------------------------------------------------------------------------------------------
1286   2              case SMB_ADDR_R_TX_ACK_RX:
1287   2                if(numBytesRD == 1)                           // If there is one byte to transfer, send a NACK and go to
1288   2                {                                   // SMB_DATA_RX_NACK_TX case to accept data from slave
1289   3                    AA = 0;                                                   // Clear AA flag before data byte is rec
             -eived
1290   3                                                                              // send NACK signal to slave after byte 
             -is received
1291   3                }
1292   2                else
1293   2                {
1294   3                    AA = 1;                                                   // More than one byte in this transfer,
1295   3                                                                              // send ACK after byte is received
1296   3                }
1297   2                break;
1298   2      
1299   2      //-------------------------------------------------------------------------------------------------------
1300   2      // Master Receiver: Slave address + READ transmitted.  NACK received. Restart the transfer
1301   2      //-------------------------------------------------------------------------------------------------------
1302   2              case SMB_ADDR_R_TX_NACK_RX:
1303   2            if(slaveAddr == MCU_SLAVE_ADDR)
1304   2            {
1305   3              if(slaveCount < MAX_NACK_RETRY)
1306   3              {
1307   4                slaveCount++;                         // Increment number of attempts when NACK is received
1308   4                STA = 1;                            // Restart transfer after receiving a NACK
1309   4              }
1310   3              else
1311   3              {
1312   4                slaveCount = 0;                         // Reset counter
1313   4                STO = 1;
1314   4                SMB_BUSY = 0;
1315   4                FAIL = 1;
1316   4              } 
1317   3            }
1318   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1319   2            {
1320   3              if(realTimeClockCount < MAX_NACK_RETRY)
1321   3              {
1322   4                realTimeClockCount++;                     // Increment number of attempts when NACK is received
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 23  

1323   4                STA = 1;                            // Restart a new transfer
1324   4              }
1325   3              else
1326   3              {
1327   4                realTimeClockCount = 0;
1328   4                STO = 1;
1329   4                SMB_BUSY = 0;
1330   4                FAIL = 1;
1331   4              } 
1332   3            }
1333   2            else if(slaveAddr == EEPROM_ADDR)
1334   2            {
1335   3              if(eepromCount < MAX_NACK_RETRY)
1336   3              {
1337   4                eepromCount++;                          // Increment number of attempts when NACK is received
1338   4                STA = 1;                            // Restart a new transfer
1339   4              }
1340   3              else
1341   3              {
1342   4                eepromCount = 0;
1343   4                STO = 1;
1344   4                SMB_BUSY = 0;
1345   4                FAIL = 1;
1346   4              } 
1347   3            }
1348   2            else
1349   2            {}
1350   2                break;
1351   2      
1352   2      //-------------------------------------------------------------------------------------------------------
1353   2      // Master Receiver: Data byte received. If AA flag was set beforehand, then ACK transmitted.
1354   2      // For a READ: receive each byte from the slave.  if this is the last byte, send a NACK and set the STOP b
             -it
1355   2      //-------------------------------------------------------------------------------------------------------
1356   2              case SMB_DATA_RX_ACK_TX:
1357   2            
1358   2            if(slaveAddr == MCU_SLAVE_ADDR)
1359   2            {
1360   3              if (RxCounter < numBytesRD)
1361   3                  {
1362   4                sharedDataRx[startAddr + RxCounter] = SMB0DAT;
1363   4                      AA = 1;                                                 // Send ACK to indicate byte received
1364   4                      RxCounter++;                                            // Increment the byte counter
1365   4                slaveReadDone = 0;                        // Mark start of slave read
1366   4                  }
1367   3                  else
1368   3                  {
1369   4                      AA = 0;                                                 // Send NACK to indicate last byte is re
             -ceived
1370   4                slaveReadDone = 1;                        // Mark end of slave read
1371   4                  }
1372   3            }
1373   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1374   2            {
1375   3              if(RxCounter < numBytesRD)
1376   3              {
1377   4                sharedDataRx[startAddr + RxCounter] = SMB0DAT;          // RTC
1378   4                rtcReadDone = 0;
1379   4                
1380   4                AA = 1;                             // Send ACK to indicate byte received
1381   4                RxCounter++;                          // Increment the byte counter
1382   4              }
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 24  

1383   3              else
1384   3              {
1385   4                rtcReadDone = 1;
1386   4                AA = 0;                             // Send NACK to indicate last byte is received
1387   4              }
1388   3            }
1389   2            else if(slaveAddr == EEPROM_ADDR)
1390   2            {
1391   3              if(RxCounter < numBytesRD)
1392   3              {
1393   4                eepromDataByte = eepromRx[RxCounter] = SMB0DAT;
1394   4                AA = 1;                             // Send ACK to indicate byte received
1395   4                RxCounter++;                          // Increment the byte counter
1396   4                eepromReadDone = 0;                       // Mark start of fram read
1397   4              }
1398   3              else
1399   3              {
1400   4                AA = 0;                             // Send NACK to indicate last byte is received
1401   4                eepromReadDone = 1;                       // Mark end of fram read
1402   4              }
1403   3            }
1404   2                break;
1405   2      
1406   2      //-------------------------------------------------------------------------------------------------------
1407   2      // Master Receiver: Data byte received. If AA flag was cleared, then NACK transmitted.
1408   2      // For a READ: Read operation has completed.  Read data register and send STOP
1409   2      //-------------------------------------------------------------------------------------------------------
1410   2              case SMB_DATA_RX_NACK_TX:
1411   2            if(slaveAddr == MCU_SLAVE_ADDR)
1412   2            {
1413   3              sharedDataRx[startAddr + RxCounter] = SMB0DAT;
1414   3                  STO = 1;                              // Stop transfer
1415   3                  SMB_BUSY = 0;                           // Release SMB
1416   3                  AA = 1;
1417   3              slaveReadDone = 1;                          // Mark end of slave read                               // Set AA for next transfer   
             -                                              
1418   3            }
1419   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1420   2            {
1421   3              sharedDataRx[startAddr + RxCounter] = SMB0DAT;            // RTC
1422   3              rtcReadDone = 1;
1423   3      
1424   3              STO = 1;                              // Stop transfer
1425   3              SMB_BUSY = 0;                           // Release SMB
1426   3              AA = 1;                               // Send ACK to indicate byte received
1427   3            }
1428   2            else if(slaveAddr == EEPROM_ADDR)
1429   2            {
1430   3              eepromRx[RxCounter] = SMB0DAT;
1431   3              STO = 1;                              // Stop transfer
1432   3              SMB_BUSY = 0;                           // Release SMB
1433   3              AA = 1;
1434   3              eepromReadDone = 1;                         // Mark end of eeprom read      
1435   3            }
1436   2                break;
1437   2      
1438   2      //-------------------------------------------------------------------------------------------------------
1439   2      // Master Transmitter: Arbitration lost
1440   2      //-------------------------------------------------------------------------------------------------------
1441   2              case SMB_ARBITRATION_LOST:
1442   2                FAIL = 1;                                                     // Indicate failed transfer
1443   2                                                                              // and handle at end of ISR
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 25  

1444   2                break;
1445   2      
1446   2      //-------------------------------------------------------------------------------------------------------
1447   2      // All other status codes invalid.  Reset communication
1448   2      //-------------------------------------------------------------------------------------------------------
1449   2              default:
1450   2                FAIL = 1;
1451   2                break;
1452   2         }
1453   1      //-------------------------------------------------------------------------------------------------------
1454   1      // If all failed, reset everything
1455   1      //-------------------------------------------------------------------------------------------------------
1456   1          if(FAIL)                                                            // If the transfer failed,
1457   1          {
1458   2              SMB0CN &= ~0x40;                                                  // Reset communication
1459   2              SMB0CN |= 0x40;
1460   2              STA = 0;
1461   2              STO = 0;
1462   2              AA = 0;
1463   2      
1464   2              SMB_BUSY = 0;                                                     // Free SMBus
1465   2      
1466   2              FAIL = 0;
1467   2                                                // Set to finish all pending processes
1468   2          slaveWriteDone = 1;                             // Mark end of slave write
1469   2          slaveReadDone = 1;                              // Mark end of slave read
1470   2              rtcWriteDone = 1;
1471   2          rtcReadDone = 1;
1472   2          eepromWriteDone = 1;                            // Mark end of eeprom write
1473   2          eepromReadDone = 1;                             // Mark end of eeprom read
1474   2        }
1475   1      
1476   1        SI = 0;                                                             // Clear interrupt flag
1477   1      }
1478          
1479          //-------------------------------------------------------------------------------------------------------
1480          // Function Name: setClockControl
1481          // Return Value: None 
1482          // Parmeters: None
1483          // Function Description: This function sets values to the real time clock control register
1484          // Check DS3232 documentation for more details of this this control register
1485          //-------------------------------------------------------------------------------------------------------
1486          void setClockControl(void)
1487          {
1488   1        sharedDataTx[RTC_START_ADDR + RTC_CONTROL] = 0x04;
1489   1        sharedDataTx[RTC_START_ADDR + RTC_CONTROL_STATUS] = 0x30; 
1490   1        writeBytesToRealTimeClock(RTC_START_ADDR + RTC_CONTROL, 2);             // Set control registers (2 byte)
1491   1      }
1492                            
1493          //-------------------------------------------------------------------------------------------------------
1494          // Function Name: setClock
1495          // Return Value: None 
1496          // Parmeters: None
1497          // Function Description: This function sets the new values to the real time clock
1498          //-------------------------------------------------------------------------------------------------------
1499          void setClock(void)
1500          { 
1501   1        unsigned char hoursAux;
1502   1        
1503   1        sharedDataTx[RTC_START_ADDR + SECONDS] = convertDecimalToBCD(seconds);        // Load all data from PC to arr
             -ay before writing
1504   1        sharedDataTx[RTC_START_ADDR + MINUTES] = convertDecimalToBCD(minutes);        // All data: seconds,.... are a
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 26  

             -lready converted to BCD
1505   1        sharedDataTx[RTC_START_ADDR + DAY] = convertDecimalToBCD(day);
1506   1        sharedDataTx[RTC_START_ADDR + DATE] = convertDecimalToBCD(date);
1507   1        sharedDataTx[RTC_START_ADDR + MONTH] = convertDecimalToBCD(month);
1508   1        sharedDataTx[RTC_START_ADDR + YEAR] = convertDecimalToBCD(year);
1509   1        
1510   1        hoursAux = convertDecimalToBCD(hours);                        // Get updated hours from user on screen
1511   1      
1512   1        hoursAux = hoursAux | 0x40;                             // Set 12/24 bit --> 12 hour mode
1513   1        
1514   1        if(amPm == 'P')
1515   1        {
1516   2           hoursAux = hoursAux | 0x60;                          // Set AM/PM bit --> PM mode
1517   2        }
1518   1        else if(amPm == 'A')
1519   1        {
1520   2           hoursAux = hoursAux & 0x5F;                          // Clear AM/PM bit --> AM mode
1521   2        }
1522   1        
1523   1        sharedDataTx[RTC_START_ADDR + HOURS] = hoursAux;
1524   1        
1525   1        writeBytesToRealTimeClock(RTC_START_ADDR, 7);                                       // Write 7 bytes to R
             -TC
1526   1      
1527   1        //resetAllDisplayCounters();                              // Update new values on screen
1528   1      }     
1529          
1530          //-------------------------------------------------------------------------------------------------------
1531          // Function Name: getClockData()
1532          // Return Value: None 
1533          // Parmeters: None
1534          // Function Description: This function gets the new values from the real time clock
1535          //-------------------------------------------------------------------------------------------------------
1536          void getClockData()
1537          {
1538   1        static unsigned char previousMonth = 0;
1539   1        static unsigned char previousDate = 0;
1540   1        static unsigned char previousYear = 0;
1541   1        static unsigned char previousHours = 0;
1542   1        static unsigned char previousMinutes = 0;
1543   1        static unsigned char previousSeconds = 0;
1544   1        
1545   1        unsigned int currentIndex = 0;
1546   1        unsigned char tempHours;
1547   1        
1548   1        readBytesFromRealTimeClock(RTC_START_ADDR, 7);                    // Get date and time (7 bytes)
1549   1      
1550   1        seconds = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + SECONDS]);        // Convert BCD to decimal for s
             -econds (1 byte)
1551   1        minutes = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + MINUTES]);        // Convert BCD to decimal for m
             -inutes (1 byte)
1552   1      
1553   1        tempHours = sharedDataRx[RTC_START_ADDR + HOURS];                 // Get BCD without conversion and check AM/PM
1554   1      
1555   1        if(tempHours & 0x40)                                // 12/24 bit (bit 6) is set --> 12 hour mode
1556   1        {
1557   2          timeMode = TWELVE_HR_MODE;
1558   2      
1559   2          if(tempHours & 0x20)                              // PM/AM bit (bit 5) is set --> PM
1560   2          {
1561   3            amPm = 'P';
1562   3          }
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 27  

1563   2          else
1564   2          {
1565   3              amPm = 'A';
1566   3          }
1567   2        }
1568   1        else
1569   1        {
1570   2          timeMode = TWENTY_FOUR_HR_MODE;
1571   2        }
1572   1      
1573   1        hours = convertBCDToDecimal(tempHours & 0x1F);                    // Get hours (bit 4 to bit 0 only. Ignore others)
1574   1      
1575   1        if(hours == 12)
1576   1        {
1577   2          if(amPm == 'A')
1578   2          {
1579   3            hours24 = 0;
1580   3          }
1581   2          else
1582   2          {
1583   3            hours24 = hours;
1584   3          } 
1585   2        }
1586   1        else
1587   1        {
1588   2          if(amPm == 'P')
1589   2          {
1590   3            hours24 = hours + 12;                           // Twenty four hour format if PM
1591   3          }
1592   2          else
1593   2          {
1594   3            hours24 = hours;                              // Twenty four hour format if AM
1595   3          }
1596   2        }
1597   1      
1598   1        day = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + DAY]);            // Convert BCD to decimal for day (1 
             -byte)
1599   1        date = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + DATE]);          // Convert BCD to decimal for date (
             -1 byte)
1600   1        month = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + MONTH]);          // Convert BCD to decimal for mont
             -h (1 byte)
1601   1        year = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + YEAR]);          // Convert BCD to decimal for year (
             -1 byte)
1602   1      
1603   1        if(month != previousMonth || date != previousDate || year != previousYear)
1604   1        {
1605   2          monthDateYearUpdated = SET;   
1606   2        }
1607   1        if(hours != previousHours || minutes != previousMinutes || seconds != previousSeconds)
1608   1        {
1609   2          timeUpdated = SET;
1610   2        }
1611   1      
1612   1        if(amPm == 'P')
1613   1        {
1614   2          currentIndex = ((12 + hours) * 60) + minutes;
1615   2        }
1616   1        else if(amPm == 'A')
1617   1        {
1618   2          if(hours == 12)
1619   2          {
1620   3            hours = 0;
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 28  

1621   3          }
1622   2          
1623   2          currentIndex = (hours * 60) + minutes;
1624   2        }
1625   1        else
1626   1        {}
1627   1      
1628   1        minuteIndex = currentIndex % 60;                          // Get minute index from 0 - 59
1629   1        hourIndex = currentIndex / 60;                            // Get hour index from 0 - 23
1630   1      
1631   1        previousDate = date;
1632   1        previousMonth = month;
1633   1        previousYear = year;
1634   1        previousHours = hours;
1635   1        previousMinutes = minutes;
1636   1        previousSeconds = seconds;
1637   1      }
1638          
1639          //-------------------------------------------------------------------------------------------------------
1640          // Function Name: moveDateTimeUp
1641          // Return Value: None 
1642          // Parmeters: None
1643          // Function Description: This function sets date and time of the clock from the touch screen by pressing t
             -he up button
1644          //-------------------------------------------------------------------------------------------------------
1645          void moveDateTimeUp(void)
1646          {
1647   1        char str[SPRINTF_SIZE];
1648   1        
1649   1        if(realTimeClockItems == MONTH_ADJUST)
1650   1        {
1651   2          adjustedMonth++;
1652   2          monthUpdated = SET;
1653   2      
1654   2          if(adjustedMonth > 12)
1655   2          {
1656   3            adjustedMonth = 1;                              // Roll over
1657   3          }
1658   2      
1659   2          sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1660   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1661   2        }
1662   1        else if(realTimeClockItems == DATE_ADJUST)
1663   1        {
1664   2          adjustedDate++;
1665   2          dateUpdated = SET;
1666   2      
1667   2          if(adjustedDate > 31)
1668   2          {
1669   3            adjustedDate = 1;                             // Roll over
1670   3          }
1671   2      
1672   2          sprintf(str, "%bu   ", adjustedDate);
1673   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1674   2        }
1675   1        else if(realTimeClockItems == YEAR_ADJUST)
1676   1        {
1677   2          adjustedYear++;
1678   2          yearUpdated = SET;
1679   2      
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 29  

1680   2          if(adjustedYear > 99)
1681   2          {
1682   3            adjustedYear = 99;
1683   3          }
1684   2      
1685   2          sprintf(str, "20%02bu", adjustedYear);
1686   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1687   2        }
1688   1        else if(realTimeClockItems == HOUR_ADJUST)
1689   1        {
1690   2          adjustedHours++;
1691   2          hoursUpdated = SET;
1692   2      
1693   2          if(adjustedHours > 12)
1694   2          {
1695   3            adjustedHours = 1;                              // Roll over
1696   3          }
1697   2      
1698   2          sprintf(str, "%bu   ", adjustedHours);
1699   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1700   2        }
1701   1        else if(realTimeClockItems == MINUTE_ADJUST)
1702   1        {
1703   2          adjustedMinutes++;
1704   2          minutesUpdated = SET;
1705   2      
1706   2          if(adjustedMinutes > 59)
1707   2          {
1708   3            adjustedMinutes = 0;
1709   3          }
1710   2      
1711   2          sprintf(str, "%bu   ", adjustedMinutes);
1712   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1713   2        }
1714   1        else if(realTimeClockItems == AMPM_ADJUST)
1715   1        {
1716   2          if(adjustedAmPm == 'P')
1717   2          {
1718   3            adjustedAmPm = 'A';
1719   3          }
1720   2          else if(adjustedAmPm == 'A')
1721   2          {
1722   3            adjustedAmPm = 'P';
1723   3          }
1724   2          else
1725   2          {}
1726   2      
1727   2          amPmUpdated = SET;
1728   2      
1729   2          sprintf(str, "%cM  ", adjustedAmPm);
1730   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1731   2        }
1732   1        else
1733   1        {}
1734   1      }
1735          
1736          //-------------------------------------------------------------------------------------------------------
1737          // Function Name: moveDateTimeDown
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 30  

1738          // Return Value: None 
1739          // Parmeters: None
1740          // Function Description: This function sets date and time of the clock from the touch screen by pressing t
             -he down button
1741          //-------------------------------------------------------------------------------------------------------
1742          void moveDateTimeDown(void)
1743          {
1744   1        char str[SPRINTF_SIZE];
1745   1      
1746   1        if(realTimeClockItems == MONTH_ADJUST)
1747   1        {
1748   2          adjustedMonth--;
1749   2            monthUpdated = SET;
1750   2      
1751   2          if(adjustedMonth < 1)
1752   2          {
1753   3            adjustedMonth = 12;                             // Roll over to hour 12
1754   3          }
1755   2          sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1756   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1757   2        }
1758   1        else if(realTimeClockItems == DATE_ADJUST)
1759   1        {
1760   2          adjustedDate--;
1761   2          dateUpdated = SET;
1762   2      
1763   2          if(adjustedDate < 1)
1764   2          {
1765   3            adjustedDate = 31;                              // Roll over to day 31
1766   3          }
1767   2      
1768   2          sprintf(str, "%bu   ", adjustedDate);
1769   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1770   2        }
1771   1        else if(realTimeClockItems == YEAR_ADJUST)
1772   1        {
1773   2          if(adjustedYear > 0)
1774   2          {
1775   3            adjustedYear--;                               // Check if it is greater than 0 before decrementing                        
1776   3          }                                       // to avoid a negative number
1777   2          else
1778   2          {
1779   3            adjustedYear = 0;                             // Roll over to 99
1780   3          }
1781   2          
1782   2          yearUpdated = SET;
1783   2      
1784   2          sprintf(str, "20%02bu", adjustedYear);
1785   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1786   2        }
1787   1        else if(realTimeClockItems == HOUR_ADJUST)
1788   1        {
1789   2          if(adjustedHours > 0)
1790   2          {
1791   3            adjustedHours--;                              // Check if it is greater than 0 before decrementing
1792   3          }                                       // to avoid a negative number
1793   2          else
1794   2          {
1795   3            adjustedHours = 12;
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 31  

1796   3          }
1797   2      
1798   2          hoursUpdated = SET;
1799   2      
1800   2          sprintf(str, "%bu   ", adjustedHours);
1801   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1802   2        }
1803   1        else if(realTimeClockItems == MINUTE_ADJUST)
1804   1        {
1805   2          if(adjustedMinutes > 0)
1806   2          {
1807   3            adjustedMinutes--;                              // Check if it is greater than 0 before decrementing
1808   3          }                                       // to avoid a negative number
1809   2          else
1810   2          {
1811   3            adjustedMinutes = 59;
1812   3          }
1813   2      
1814   2          minutesUpdated = SET;
1815   2      
1816   2          sprintf(str, "%bu   ", adjustedMinutes);
1817   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1818   2        }
1819   1        else if(realTimeClockItems == AMPM_ADJUST)
1820   1        {
1821   2          if(adjustedAmPm == 'P')
1822   2          {
1823   3            adjustedAmPm = 'A';
1824   3          }
1825   2          else if(adjustedAmPm == 'A')
1826   2          {
1827   3            adjustedAmPm = 'P';
1828   3          }
1829   2          else
1830   2          {}
1831   2      
1832   2          amPmUpdated = SET;
1833   2      
1834   2          sprintf(str, "%cM  ", adjustedAmPm);
1835   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1836   2        }
1837   1        else
1838   1        {}
1839   1      }
1840          
1841          //-------------------------------------------------------------------------------------------------------
1842          // Function Name: enterDateTime
1843          // Return Value: None 
1844          // Parmeters: None
1845          // Function Description: This function confirms the date or time set by the user on the touch screen
1846          //-------------------------------------------------------------------------------------------------------
1847          void enterDateTime(void)
1848          {
1849   1        char str[SPRINTF_SIZE];
1850   1        
1851   1        realTimeClockItems++;                               // Move to next item
1852   1        
1853   1        if(realTimeClockItems == MONTH_ADJUST)
1854   1        {
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 32  

1855   2          monthUpdated = SET;
1856   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MONTH ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1857   2          sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1858   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1859   2        }
1860   1        else if(realTimeClockItems == DATE_ADJUST)
1861   1        {
1862   2          dateUpdated = SET;
1863   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET DATE  ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1864   2          sprintf(str, "%bu   ", adjustedDate);
1865   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1866   2        }
1867   1        else if(realTimeClockItems == YEAR_ADJUST)
1868   1        {
1869   2          yearUpdated = SET;
1870   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET YEAR  ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1871   2          sprintf(str, "20%02bu", adjustedYear);
1872   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1873   2        }
1874   1        else if(realTimeClockItems == HOUR_ADJUST)
1875   1        {
1876   2          hoursUpdated = SET;
1877   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET HOUR  ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1878   2          sprintf(str, "%bu   ", adjustedHours);
1879   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1880   2        }
1881   1        else if(realTimeClockItems == MINUTE_ADJUST)
1882   1        {
1883   2          minutesUpdated = SET;
1884   2          amPmUpdated = SET;                                // Set it anyway because user usually does not set at the end
1885   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MINUTE", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1886   2          sprintf(str, "%bu   ", adjustedMinutes);
1887   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1888   2        }
1889   1        else if(realTimeClockItems == AMPM_ADJUST)
1890   1        {
1891   2          amPmUpdated = SET;                                // Set it anyway because user usually does not set at the end
1892   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET AM/PM ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1893   2          sprintf(str, "%cM  ", adjustedAmPm);
1894   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1895   2        }
1896   1        else if(realTimeClockItems == DONE_ADJUST)
1897   1        {
1898   2          amPmUpdated = SET;                                // Set it if user explicitly press enter button
1899   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "PRESS DONE", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1900   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, "----", VALUE_DISPLAY_X, VALUE_DISPL
             -AY_Y);
1901   2        }
1902   1        else if(realTimeClockItems == ROLL_OVER_ADJUST)
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 33  

1903   1        {
1904   2          realTimeClockItems = MONTH_ADJUST;                        // Set it for next round of real time clock items
1905   2          monthUpdated = SET;
1906   2          displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MONTH ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1907   2          sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1908   2          displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1909   2        }
1910   1        else
1911   1        {}
1912   1      }
1913          
1914          //-------------------------------------------------------------------------------------------------------
1915          // Function Name: setClockOnScreen
1916          // Return Value: None 
1917          // Parmeters: None
1918          // Function Description: This function sets the real time clock on the touch screen
1919          //-------------------------------------------------------------------------------------------------------
1920          void setClockOnScreen(void)
1921          {   
1922   1        unsigned char hoursAux;
1923   1        
1924   1        if(monthUpdated == SET)
1925   1        {
1926   2          sharedDataTx[RTC_START_ADDR + MONTH] = convertDecimalToBCD(adjustedMonth);    // Get updated month from us
             -er on screen
1927   2          writeBytesToRealTimeClock(RTC_START_ADDR + MONTH, 1);             // Set month only (1 byte)
1928   2          monthUpdated = CLEAR;                             //Clear flag after writing to real time clock                         
1929   2        }
1930   1        
1931   1        if(dateUpdated == SET)
1932   1        {
1933   2          sharedDataTx[RTC_START_ADDR + DATE] = convertDecimalToBCD(adjustedDate);    // Get updated date from user 
             -on screen
1934   2          writeBytesToRealTimeClock(RTC_START_ADDR + DATE, 1);              // Set date only (1 byte)
1935   2          dateUpdated = CLEAR;
1936   2        }
1937   1      
1938   1        if(yearUpdated == SET)
1939   1        {
1940   2          sharedDataTx[RTC_START_ADDR + YEAR] = convertDecimalToBCD(adjustedYear);    // Get updated year from user 
             -on screen
1941   2          writeBytesToRealTimeClock(RTC_START_ADDR + YEAR, 1);              // Set year only (1 byte)
1942   2          yearUpdated = CLEAR;
1943   2        }
1944   1      
1945   1        if(hoursUpdated == SET || amPmUpdated == SET)
1946   1        {
1947   2          hoursAux = convertDecimalToBCD(adjustedHours);                  // Get updated hours from user on screen
1948   2          
1949   2          if(amPmUpdated == SET)
1950   2          {
1951   3            amPm = adjustedAmPm;                            // Set updated amPm from user on screen
1952   3          
1953   3            hoursAux = hoursAux | 0x40;                         // Set 12/24 bit --> 12 hour mode
1954   3            
1955   3            if(adjustedAmPm == 'P')
1956   3            {                                 
1957   4              hoursAux = hoursAux | 0x60;                       // Set AM/PM bit --> PM mode
1958   4            }
1959   3            else if(adjustedAmPm == 'A')
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 34  

1960   3            {                                 
1961   4              hoursAux = hoursAux & 0x5F;                       // Clear AM/PM bit --> AM mode
1962   4            }
1963   3            else
1964   3            {}
1965   3      
1966   3            amPmUpdated = CLEAR;
1967   3          }
1968   2          
1969   2          sharedDataTx[RTC_START_ADDR + HOURS] = hoursAux;
1970   2          writeBytesToRealTimeClock(RTC_START_ADDR + HOURS, 1);             // Set hours only (1 byte)
1971   2          hoursUpdated = CLEAR; 
1972   2        }
1973   1      
1974   1        if(minutesUpdated == SET)
1975   1        {
1976   2          sharedDataTx[RTC_START_ADDR + MINUTES] = convertDecimalToBCD(adjustedMinutes);  // Get updated minutes fr
             -om user on screen
1977   2          writeBytesToRealTimeClock(RTC_START_ADDR + MINUTES, 1);             // Set minutes only (1 byte)
1978   2          minutesUpdated = CLEAR;
1979   2        }
1980   1      
1981   1        realTimeClockItems = MONTH_ADJUST;                          // Set starting item = Month for adjustment
1982   1      
1983   1        getClockData();                                     // Get current month, date, year set by user
1984   1      
1985   1        //clockSetupDisplayRepeat = 0;                            // Display clock updates on screen                                    // Syste
             -m goes back to main page          
1986   1      }
1987          
1988          //-------------------------------------------------------------------------------------------------------
1989          // Function Name: resetClock
1990          // Return Value: None 
1991          // Parmeters: None
1992          // Function Description: This function resets the real time clock to 0:00:00 1/1/2000
1993          //-------------------------------------------------------------------------------------------------------
1994          void resetClock(void)
1995          {
1996   1        seconds = 0;
1997   1        minutes = 0;
1998   1        hours = 0;
1999   1        amPm = 'P';
2000   1        day = 1;
2001   1        date = 1;
2002   1        month = 1;
2003   1        year = 0;
2004   1        century = 0;
2005   1        timeMode = 1;
2006   1      
2007   1        setClock();                                             // Set real time clock
2008   1      }
2009          
2010          //-------------------------------------------------------------------------------------------------------
2011          // Function Name: convertDecimalToBCD
2012          // Return Value: bcd 
2013          // Parmeters: decimal
2014          // Function Description: This function converts a decimal number to a BCD when writing the new value to th
             -e real time clock
2015          //-------------------------------------------------------------------------------------------------------
2016          unsigned char convertDecimalToBCD(unsigned char decimal)
2017          {
2018   1        unsigned char bcd;
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 35  

2019   1      
2020   1        bcd = (decimal / 10) << 4;                              // Get upper 4 bits
2021   1        bcd = bcd | (decimal % 10);                             // Get a BCD
2022   1      
2023   1        return bcd;
2024   1      }
2025          
2026          //-------------------------------------------------------------------------------------------------------
2027          // Function Name: convertBCDToDecimal
2028          // Return Value: decimal value 
2029          // Parmeters: bcd
2030          // Function Description: This function converts a BCD to a decimal number when reading the current value f
             -rom the real time clock
2031          //-------------------------------------------------------------------------------------------------------
2032          unsigned char convertBCDToDecimal(unsigned char bcd)
2033          {
2034   1        unsigned char decimal;
2035   1      
2036   1        decimal = ((bcd >> 4) * 10) + (bcd & 0x0F);                     // Combine upper and lower nibbles to get
2037   1                                                  // 8 bit number
2038   1        return decimal;
2039   1      }
2040          
2041          //-------------------------------------------------------------------------------------------------------
2042          // Function Name: displayClock
2043          // Return Value: None 
2044          // Parmeters: None
2045          // Function Description: This function displays clock data on the touch screen
2046          // The clock format is MM/DD/YYYY hour/minute/second
2047          //-------------------------------------------------------------------------------------------------------
2048          void displayClock(void)
2049          {
2050   1        char str[SPRINTF_SIZE];
2051   1        
2052   1        //if(screen == MAIN_PAGE)
2053   1        //{
2054   1              getClockData();
2055   1      
2056   1              sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month], date, year);
2057   1              displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, SETTINGS_DATE_X, SETTINGS
             -_DATE_Y);
2058   1              monthDateYearUpdated = CLEAR;
2059   1              
2060   1              sprintf(str, "%2bu:%02bu:%02bu %cM ", hours, minutes, seconds, amPm);
2061   1              displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, SETTINGS_TIME_X, SETTINGS
             -_TIME_Y);
2062   1        //}
2063   1        /*else if(screen == CLOCK_SETUP_PAGE)
2064   1        {
2065   1          if(buttonPressed == CLEAR)
2066   1          {
2067   1            getClockData();
2068   1        
2069   1            sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month], date, year);
2070   1            displayText(DATE_DISPLAY_FG, DATE_DISPLAY_BG, DATE_DISPLAY_FONT, str, DATE_DISPLAY_X, DATE_DISPLAY_Y);
2071   1            monthDateYearUpdated = CLEAR;
2072   1      
2073   1            sprintf(str, "%2bu:%02bu:%02bu %cM ", hours, minutes, seconds, amPm);
2074   1            displayText(TIME_DISPLAY_FG, TIME_DISPLAY_BG, TIME_DISPLAY_FONT, str, TIME_DISPLAY_X, TIME_DISPLAY_Y);
2075   1            timeUpdated = CLEAR;
2076   1          }
2077   1        }*/
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:46:11 PAGE 36  

2078   1      }
2079          
2080          //-------------------------------------------------------------------------------------------------------
2081          // Main
2082          //-------------------------------------------------------------------------------------------------------
2083          
2084          void main()
2085          {
2086   1        int i = 0;
2087   1          char str[SPRINTF_SIZE];
2088   1          int testCounter = 0;
2089   1          
2090   1          disableWatchdog();
2091   1          systemClockInit();
2092   1        portInit();
2093   1        enableInterrupts();
2094   1        uart0Init();
2095   1          smbInit();
2096   1          timer3Init();
2097   1          
2098   1          tsLastCharGone = 1;
2099   1          tsTxOut = tsTxIn = 0;
2100   1          tsTxEmpty = 1;
2101   1        changeScreen(MAIN_PAGE);
2102   1          
2103   1        while(1)
2104   1        {
2105   2          if(screen == MAIN_PAGE && metricUnits == 1){
2106   3              printTempC();
2107   3          }else if(screen == MAIN_PAGE && metricUnits == 0){
2108   3              printTempF();
2109   3          }
2110   2            scanUserInput();                                                        // Detect a string input from t
             -he touch screen
2111   2          
2112   2              
2113   2              //roomTemp2 = readOneByteFromSlave(ROOM_TEMP_2);
2114   2             
2115   2              displayClock();
2116   2        }
2117   1      }
*** WARNING C280 IN LINE 2087 OF main.c: 'str': unreferenced local variable


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7143    ----
   CONSTANT SIZE    =    474    ----
   XDATA SIZE       =   3576     755
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     20       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
